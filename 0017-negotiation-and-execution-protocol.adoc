= Separating negotiation and execution phase =
Thomas Eizinger <thomas@coblox.tech>; Philipp Hoenisch <philipp@coblox.tech>; Daniel Karzel <daniel.karzel@coblox.tech>;
:toc:
:revdate: 2019-10-05
:sectnums:
:sectnumlevels: 5

NOTE: Author: {authors} +
Date: {revdate} +
Tracking issue: https://github.com/comit-network/comit-rs/issues/1413[#1413]

== Context ==

Over time we came to the conclusion that our protocol stack in general, and RFC003 in particular, is difficult to understand in certain ways.

We could specify several problems:

. The Accept/Decline feels weird, it often does not make sense in specific use-case context.
. We do not clearly distinguish trade negotiation from execution at the moment.
. It is hard to add the concept of orders and an order-book to COMIT.

This spike includes:

. Solution proposal for splitting trade negotiation and execution in different protocols.
. Solution proposal for the "How to update an offer"/"Offers should not get stale" problem.
. Defining the base for a first negotiation protocol.
. Defining the changes needed to the existing execution protocol RFC003.

== Research ==

=== Constraints

Before defining the terminology certain constraints shall be defined, so we know what is already regarded as given.

==== Protocol Constraints

As we build upon libp2p for messaging all protocols should adhere to the libp2p specification.

For the sake of simplicity we assume that there is only one protocol (RFC003) for trade execution at the moment.
In the future there will be more execution protocols.

The negotiation protocol is designed with a decentralized orderbook in mind.
It should be possible to use an adapted version of the protocol to realize a central orderbook.

==== Offers Constraints

During the negotiation phase the offer can be changed multiple times.
Once the negotiation phase comes to a successful end (the parties agree on the parameters for the execution) the execution phase is triggered (immediately).
Note that there might still be an implicit accept of the message sent from taker to maker when sending over parameters.

=== cnd Constraints

There are two extreme sides for going with cnd:

. *cnd as a protocol wrapper:* you tell cnd "here are all the parameters to do an atomic swap, please do it."
.. The input to cnd would have to be sufficient to start executing immediately.
..   There is not message exchange in the execution phase, cnd just monitors blockchains.
. *cnd as jack of all trades:* you tell cnd "here are the asset and amount I have and want, find me a partner to trade."
.. cnd would manage everything from orderbook, negotiation till the execution

Both 1. and 2. have advantages and disadvantages.

Decisions for this spike:

- cnd should focus on the execution of a swap.
- execution and negotiation should be separated as good as possible (parameters should not leak from execution to negotiation).
- cnd should have more power than just being a wrapper. It should be able to come up with e.g. default expiries.

=== Definitions

==== Trade ====

In the COMIT context a trade is always between two digital assets.

We identify two main phases when it comes to a trade:

. Negotiation: The phase where the maker comes up with one or multiple offers, publishes them and a taker takes a specific offer.
The outcome of the negotiation phase should be the parameters needed for execution.
. Execution: The phase where the trade is executed, hence actions are executed on the ledger.

Basic idea of the steps of a trade as defined by this spike:

. Trade Invitation (maker -> world)
. Negotiation (P2P)
.. Offer Request (taker -> maker)
.. Offer (maker -> taker)
. Execution (P2P)

==== Negotiation and Execution Roles ====

The negotiation phase of a trade specifies two roles:

* Maker: Creates offers
* Taker: Takes offers

Note that these roles are orthogonal to the cryptographic roles (Alice and Bob) in the execution protocol.
Both the maker and the taker can theoretically be in the role of Alice (who generates the secret) or Bob.
During the negotiation phase both parties have to reach agreement on who will be in the role of Alice and who will be in the role of Bob.

==== Bid and Ask ====

In the context of this document Bid and Ask is always from the market maker point of view.

* Bid: The amount of asset the maker offers.
* Ask: The amount of asset the maker asks for from a potential taker.


=== Recommendation for protocol changes

The general idea is to first define what parameters are needed for the execution phase and then design a negotiation protocol that outputs these parameters for the execution.

As RFC003 is currently the only implementation of an execution protocol we focus on this protocol.
Once more execution protocols are defined we will have to define more negotiation protocols according to the parameters required by the execution protocol.
This means, that some negotiation protocols could be re-used for multiple execution protocols if the execution protocols have the same input parameters.

=== Invitation phase

We introduce an invitation phase in order to enable decentralization.
Makers don't necessarily have a central order book, the invitation helps them to overcome the problem of decentral offers getting stale.

On an abstract level an invitation protocol can be defined as a function:

```
fn invitation() -> negotiation_params[] {
    // steps (messages) needed to come from nothing to negotiation_params
}
```

==== Communication

Message Overview:

![Invitation](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/comit-network/spikes/master/assets/0017-SequenceDiagram-InvitationPhase.puml&fmt=svg)

==== Trade Invitation ====

The trade invitation specifies which assets on which ledgers a maker _is willing_ to trade.
The trade invitation is not necessarily part of the negotiation.
Its purpose is to connect maker and taker.

An asset-availability is defined by:

[%header,cols=1*]
|===
|required

|connection-info
|bid-asset
|ask-asset
|===

[%header,cols=1*]
|===
|optional

|timestamp
|bid-amount
|ask-amount
|===

Constraints:

* Connection-info currently consists of IP-address and libp2p peer-id
* The optional parameters help takers to understand what a maker was capable of at a certain point in time.

When designing the negotiation protocol
One should aim for a standardized format for trade invitations to be able to process them in the negotiation phase.


=== Negotiation protocol

On an abstract level the negotiation protocol can be defined as a function:

```
fn negotiation(negotiation_params[]) -> execution_params[] {
    // steps (messages) needed to come from negotiation_params to execution_params
}
```

The output of the negotiation protocol should enable the execution phase.
As we only have one execution protocol (RFC003 - Atomic Swaps using HTLCs) at the moment this negotiation protocol will be designed to output the parameters for that protocol.

Asset-availability handling (i.e. building a central order-book) is not part of this protocol.

The invitation phase may be part of an implementation of a negotiation protocol.

==== Negotiation Input Parameters

The minimum input parameters for the protocol are:

* ledger/asset pair
* connection-info (of the negotiation protocol)

These input parameters are the output of the invitation phase.

==== Negotiation Output Parameters

The output of the negotiation protocol should enable the execution phase.
However, the negotiation phase should be functionally decoupled from the execution phase.

The execution phase needs the following parameters on both sides in order to start the execution:

* id to reference the swap
* role
* ledger-asset pairs
* amounts
* execution protocol
* expiries
* identities

Out of these parameters the following are relevant for negotiating the price:

* ledger-asset pairs
* amounts
* execution protocol
* expiries

Constraints:

* Execution protocol and expiries MAY have an implication on the price.
We decided to have the expiries as part of the negotiation for now.
The protocol will just default to the only protocol that currently exists in the execution phase.
If the expiries are not taken into account during the negotiation the execution phase should be able to come up with default expiry times.
* Identities don't have an implication on the price negotiation and should not be exposed to the negotiation protocol.

Since there is only one protocol at the moment the execution phase will always default to that protocol.
The negotiation phase has to define an id that is passed on to the execution phase of referencing the swap.

The output parameters of the negotiation phase are defined like this:

[%header,cols=1*]
|===
|required

|offer id
|valid until
|bid-ledger
|bid-asset
|bid-amount
|ask-ledger
|ask-asset
|ask-amount
|_execution_ swap-id
|_execution_ connection-info
|_execution_role
|===

[%header,cols=1*]
|===
|optional

|_execution_ expiries
|===

===== Deciding the Execution Role

Assumption: In order to motivate the maker to create offers the expiries for the maker should be shorter than for the taker.
This, in a way, ensures liquidity in the network as it is more attractive to create offers.

As the expiries for the actor in the role of Bob are shorter:

* The maker should automatically default to Bob.
* Consequently, the taker defaults to the role of Alice.

For future protocols this can be revised.

==== Communication

The negotiation protocol builds on the assumption that the taker already has received an trade invite from the maker.
The taker knows how to contact the maker for requesting a specific offer.

Message Overview:

![Negotiation](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/comit-network/spikes/master/assets/0017-SequenceDiagram-NegotiationPhase.puml&fmt=svg)

===== P2P Offer Request

Message from the taker to the maker to receive a specific offer.
This offer might be different from the trade invitation information, as the maker might have been trading since publishing the invitation.

[%header,cols=1*]
|===
|required

|bid-ledger
|bid-asset
|ask-ledger
|ask-asset
|===

===== P2P Offer

Message from the maker to the taker that specifies a specific offer to be executed.

[%header,cols=1*]
|===
|required

|offer id
|valid until
|bid-ledger
|bid-asset
|bid-amount
|ask-ledger
|ask-asset
|ask-amount
|_execution_ connection-info
|===

[%header,cols=1*]
|===
|optional

|_execution_ expiries
|===

Constraints:

* The offer ID is a unique identifier for one specific offer.
* Once the taker send an offer request, the returned offer by the maker is for the taker specifically.
It has a timestamp defining until when it is valid.

The offer ID is used to be able to link the swap execution back to the negotiation.

===== P2P Take Offer

Message from the taker to the maker that specifies that the taker wants to take a specific offer previously received from the maker.

[%header,cols=1*]
|===
|required

|offer id
|bid-amount
|ask-amount
|===


The bid and ask amount has to be a fraction of the bid and ask amounts returned by the maker (otherwise the maker will most likely decline the take offer).

Note that in this design the taker cannot specify expiries.
He can accept the (optional) expiries defined by the maker or use the cnd's default expiries.

===== Acknowledgement for Take Offer

Message from the maker to the taker that kicks-off the execution phase.
The maker generates a unique swap-id and sends it to the taker.
The swap-id will be used to identify the swap during the execution phase, it can be use to link the execution to the offer.

[%header,cols=1*]
|===
|required

| offer id
| swap-id
|===

==== Shortcomings

This first simple negotiation protocol does not really specify an orderbook in the sense that a user can compare ALL available offers.
A taker can only process the offers of known makers.
Every taker is responsible for keeping its own list of known makers and evaluate the offers.
There may exist unknown makers that offer a better rate.

The invitation and negotiation phase can be enhanced by different features that may depend on the underlying use-case.
Ideas for additional features:

* Allows price targeting for individual takers by adding an id to invitations.
* Allow takers to specify alternative expiries when taking an offer.

=== Changes to the existing execution protocol RFC002/RFC003

Constraints:

. Taker defaults to Alice, Maker defaults to Bob
. The taker has received connection information to contact the maker for execution in the negotiation phase.

==== Input parameters

===== Execution Parameter Definition

For the execution phase as specified by RFC003 we need the parameters for creating the HTLCs on both sides:

- alpha_ledger.name
- alpha_asset.name
- alpha_asset.quantity
- beta_ledger.name
- beta_asset.name
- beta_asset.quantity
* expiries
* hash(secret)
* identities

In order to come up with these parameters we need:

* role (to know who comes up with the secret)

In order to know how to construct the HTLCs and which messages are to be exchanged we nee:

* protocol

===== Negotiation Output

From the negotiation phase we have the following output parameters:

[%header,cols=1*]
|===
|required

|offer id
|valid until
|bid-ledger
|bid-asset
|bid-amount
|ask-ledger
|ask-asset
|ask-amount
|_execution_ swap-id
|_execution_ connection-info
|_execution_role
|===

[%header,cols=1*]
|===
|optional

|_execution_ expiries
|===

It is expected, that both maker and taker create the swap for execution in cnd directly after the negotiation phase is finished.
The taker has received the execution connection information from the maker during the negotiation phase. Thus, the taker's cnd send the first message.

===== Parameter Mapping

This section defines the input parameters for cnd and how to map them from the negotiation phase.

[%header,cols=2*]
|===
|execution (required)
|negotiation

|swap_id
|swap-id

|beta_ledger
|bid-ledger

|beta_asset.name
|bid-asset

|beta_asset.amount
|bid-amount

|alpha_ledger
|ask-ledger

|alpha_asset.name
|ask-asset

|alpha_asset.amount
|ask-amount

| connection_info
|_execution_ connection-info

|role
|_execution_ role

|===

[%header,cols=2*]
|===
|execution (optional)
|negotiation

|expiries
|_execution_ expiries

|identities
|
|===

Constraints:

* The connection-info is only provided to the cnd in the role of Alice.
* If the expiries were not part of the negotiation output cnd will come up with defaults.
* Identities might be provided by the user. If no identities are provided the cnd will come up with defaults.

==== Communication changes

Instead of a request-response model we propose a messaging model where both parties supply the same parameter to the execution on both sides.
The CND nodes of the 2 parties execute the swap automatically if the parameters of the counterparty define an executable swap.
Thus, once one party adds a swap to the pool, cnd sends a message to the counterparty's cnd to verify that the same swap is defined there too.

This requires:

* Changing the messaging so that both parties can just supply the input parameters for the execution and cnd sends messages to match the parameters.
** Sending such kind of messages does include the exchange of execution specific parameters that were not defined during negotiation (e.g. identities and hash of secret, which are not price relevant).
* In the best case scenario there is no user interaction needed. There is no explicit accept as such any more.
** The swap is deemed executable once the parameters match on both sides.
* Once the parameters match the taker (which defaulted to Alice) gets the fund transaction, the maker cnd monitors alpha-ledger for funding.

Messaging:

![Execution](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/comit-network/spikes/master/assets/0017-SequenceDiagram-ExecutionPhase.puml&fmt=svg)

== Summary of recommendations ==

=== Optimizing for the user

In the "best case" scenario, i.e. a scenario without any errors that assumes cnd coming up with default identities and default expiries the human interaction is kept to a bare minimum:

. Maker: create and publish trade invitation
. Taker: take offer

Constraints:

. The actual offer (in the maker app) can be kept up to date automatically on the maker side.
. Offer invitations can be automatically processed on the taker side.
. Offer requests can be automated sent (periodically query for the current rate) on the taker side.
. The execution phase assumes two cnd that run compatible versions.
. In order to come up with indentities cnd has to use tansient keys.
. Fund and redeem of maker and taker are handled automated (i.e. an application sends the transactions provided by cnd).

The proposed solutions are a middle ground between convenience for applications on top and security.
The security level is slightly lowered by using e.g. transient keys.

=== Negotiation protocol

For a first version of the negotiation protocol it might be easier to combine the invitation and negotiation phase into one protocol.

=== Execution protocol changes

Adapt the communication according to the sequence diagram specifying the execution phase messaging.

