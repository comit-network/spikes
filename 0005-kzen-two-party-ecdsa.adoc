= Kzen Two Party ECDSA Review
Lloyd Fournier <lloyd@coblox.tech>
:toc:
:revdate: 2019-05-10

* Authors(s): {authors}
* Date: {revdate}

Issue: https://github.com/comit-network/comit-rs/issues/897[#897]


== Context

In order to do a _Scriptless Scripts_ atomic swap <<Sanchez18a>> with ECDSA signatures we need to have an implementation of <<Lindell17>>.
The point of this spike is to review <<Lindell17>> and KZen's rust implementation <<kzen_mp_ecdsa>> and make notes about.


== Overview

[[Lindell17]] describes a two-party protocol to (i) generate a joint public key and (ii) jointly create ECDSA signatures under that public key.
This is usually called signature _aggregation_.
There's a video by the Lindell summarizing his paper here: https://www.youtube.com/watch?v=pwc_Ork-1aA

Aggregated signatures are a nice thing to have.
They look exactly like normal signatures but are produced by multiple parties instead of one.
Practically, this means you don't need to lock Bitcoin to multiple public keys and check the signature with `OP_CHECKMULTISIG`; you can just lock it to a joint public key using a normal `P2WSH` output (i.e. use `OP_CHECKSIG`). There's no way to tell the difference between a single user `P2WSH` output and a `P2WSH` output from a joint public key.

Since ECDSA signatures doesn't have a nice algebraic structure it is **very** difficult to do signature aggregation.
In schnorr you can quite literally just add each party's share of the signature together.
The method we have to use in ECDSA is to move the operations to produce the *s* component of the signature into a [Paillier group](https://en.wikipedia.org/wiki/Paillier_cryptosystem) rather than doing them simply modulo the Secp256k1 curve order.
Once you're in Paillier land things become much easier but it comes at a cost of boatloads of messages and complexity during the key generation and exchange phase.
It is so complicated that it's amazing that anyone actually bothered to come up with this.
For us it may be very useful. Even though Bitcoin will get Schnorr signatures, Ethereum probably won't switch anytime soon.

Once the keys are generated, The two parties (P1 and P2) do the signing like this (roughly):

1. P1 sends the Paillier encryption of their private key to P2 (this is actually done in the keygen phase)
2. P2 uses the encrypted private key and Paillier homomorphic operations (addition and multiplication) to build a new ciphertext which has P2's parts of the signature in it and sends it to P1.
3. P1 then decrypts it and has enough to produce the signature.

The code for the signing part is in the main 2pECDSA crate: https://github.com/KZen-networks/multi-party-ecdsa/blob/e5a741bf8dd756b650b35ef8d65f6cecbd4f196a/src/protocols/two_party_ecdsa/lindell_2017/

The hard bit is doing the setup phase which involves quite a few proofs.
Some of them are in the above crate but some of them are imported from elsewhere.
Here's a list of the main proofs that are needed to implement the protocol.


== Key Generation

=== Generating the joint Public key

To produce signatures under a joint public key you first need generate it fairly.
Because of rogue key attacks, you can't just have one party send their public key and the other send one back.

The technique used in the paper (and followed by the implementation) is to do a coin tossing like protocol.
This ensures that the public key is totally random and cannot be biased by the party that chooses their key afterwards.

Note, The ability to simulate a random coin toss gives the key generation very strong security guarantees (they are able to do a simulation based proof).

The protocol is roughly as follows:

- P1 -> Hash(p1_public_key, schnorr_nizk(p1_public_key))
- P2 -> p2_public_key, schnorr_nizk(p2_public_key)
- P1 -> Opens commitment from first message
- Both parties calculate `joint_public_key = p1_public_key + p2_public_key`.

==== Implementation notes
The implementation commits by sending two hashes, one for the key and one for the NIZK.

The NIZK is implemented here: https://github.com/KZen-networks/curv/blob/18f0081a9a3025eafd49ad496e5032647edf4aa3/src/cryptographic_primitives/proofs/sigma_dlog.rs

=== Proving Paillier modulus is well formed

In order to use Paillier encryption P1 needs to generate a RSA type modulus `N = pq` where `p` and `q` are large primes.
P1 needs to prove that she generated `N` properly (I don't actually know what the risk is to P2 if she doesn't).

The proof mentioned in the original paper is <<Hazay11>>.
But in a more recent paper on multi-party ECDSA, <<Lindell18>> modifies the proof from <<Goldberg18>> to do the job (see section 6.2.3).
Roughly speaking, the strategy is to prove that `N` is *square free* and to show that `f(x) = x ^ N (mod N)` is a permutation which proves that `N = pq` form.

=== Implementation notes

Since it's a public coin protocol, you can make an non-interactive version of the proof using the [Fiat-Shamir transformation](https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic).
They've implemented a non-interactive version of it here: https://github.com/KZen-networks/zk-paillier/blob/a7f3907fb2b3464f12b55e3ad2f50405db54f36a/src/zkproofs/correct_key_ni.rs (which uses the interactive proof module but supplies the challenge as a hash of the initial commitment).


=== Proving a Paillier encryption is a private key of a EC public key

To do the signing protocol, we need one party (P2) to have the encrypted pivate key of the other (P1).
In order for P2 to know that he's signing under their joint public key, he has to know that this encrypted private key is the right one (without learning what the private key is).

The proof is described in <<Lindell17>> (section 6).
It's a little tricky to get your head around.
First P2 sends a challenge to P1.
If P1's response to the challenge is valid then P2 knows that the encrypted private key corresponds to `p1_public_key`.

The weird thing is that P1 doesn't actually use his knowledge of what private key is in order to produce the proof the encrypted private key is correct.
He simply uses his ability to decrypt the Paillier encryption.
In other words, anyone who knows the factorization `N = pq` can make this proof to P2.
The proof is not showing knowledge of the private key, just that the encrypted private key is indeed the preimage of `p1_public_key`.

=== Implementation notes

This proof isn't in its own module but the code for it hangs around with the rest of the protocol:

https://github.com/KZen-networks/multi-party-ecdsa/blob/e5a741bf8dd756b650b35ef8d65f6cecbd4f196a/src/protocols/two_party_ecdsa/lindell_2017/party_one.rs
(look for things starting with `PDL`).

It looks like this protocol cannot be made non-interactive. It requires four round of communication.

=== Range proof

In order for the previous proof to actually prove the statement you have to couple it with a range proof which proves that the encrypted private key is in the curve order (i.e. is a valid private key).
The poof chosen was originally from <<Boudot>>  but I found it was easier to understand in <<Lindell17>> anyway (see Appendix A).

The proof uses the cut and choose technique, so it's quite large.
It's tricky to understand, but doesn't use any wonky math.
You just have to follow what happens closely.

==== Implementation notes

To prove that the private key lies within the curve order P1 first has to choose their private key so that it's in `Z_q/3` rather than `Z_q`.
Without this the proof will not be _complete_.

It's implemented here:

https://github.com/KZen-networks/zk-paillier/blob/a7f3907fb2b3464f12b55e3ad2f50405db54f36a/src/zkproofs/range_proof.rs

[Bibliography]
== References

- [[Sanchez18a]] Scriptless Scripts with ECDSA, https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf
- [[Lindell17]] Fast Secure Two-Party ECDSA Signing: https://eprint.iacr.org/2017/552.pdf
- [[kzen_mp_eds]] KZen's rust implementation: https://github.com/KZen-networks/multi-party-ecdsa
- [[Hazay11]] Efficient RSA Key Generation and Threshold Paillier in the Two-Party Setting: https://eprint.iacr.org/2011/494.pdf
- [[Lindell18]] Fast Secure Multiparty ECDSA with Practical Distributed Key Generation and Applications to Cryptocurrency Custody: https://eprint.iacr.org/2018/987.pdf
- [[Goldberg18]] Certifying RSA Public Keys with an Efficient NIZK: https://eprint.iacr.org/2018/057.pdf
- [[Boudot00]] Efficient Proofs that a Committed Number Lies in an Interval: https://www.iacr.org/archive/eurocrypt2000/1807/18070437-new.pdf
