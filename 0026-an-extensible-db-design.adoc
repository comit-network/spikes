= Database design for cnd
Philipp Hoenisch <philipp@coblox.tech>
:toc:
:revdate: 2020-04-23

NOTE: Author: {authors} +
Date: {revdate} +
Status: Draft



== Problem

Our current database design is complex and hard to maintain or extend.

=== Database normalization

Database normalization is a process to organize a database into tables and columns.
The main idea with this is that a table should be about a specific topic and only supporting topics included.
If a table is not properly normalized and has data redundancy then it will not only eat up extra memory space but will also make it difficult to handle and update the database, without facing data loss. Insertion, Updation and Deletion Anomalies are very frequent if database is not normalized.
There are three main reasons to normalize a database.

* to minimize duplicate data,
* to minimize or avoid data modification issues,
* to simplify queries.


==== 1 NF:
* each cell to be a single value
* entries in a column are of the same type
* rows are uniquely identified - i.e. each row has a unique ID

==== 2 NF:
* all attributes (non-key columns) depend on the key - if not, then a conjunction table should be created consisting out of 2 keys joining two otherwise not dependent tables (e.g. protocol and swap)

==== 3 NF:
* all fields (all columns) can be determined only by the key in the table and no other column. E.g. if for every Han_BTC swap we have the same expiries, then this should be an own table. --> update anomaly

==== 4 NF:
* no multi-valued dependencies. E.g. a customer who bought 2 items should not be in a table twice with the bought item in one column


== What is the data we need to store

.Swap Swap
|===
|Swap request | Description

| sent
|

| received
|

| accepted (finalized)
|

| deployed
|

| funded
|

| invalid_funded
|

| redeemed
|

| refunded
|

|===


.Swap Swap
|===
|Swap events | Description

| on_chain_events
|

| off_chain_events
|

|===


== Database normalization

=== Phase 0

Instead of going from what we have right now, we start with a slightly adapted table layout based on the one proposed by @bonomat
https://3.basecamp.com/4403044/buckets/16118249/messages/2583518881#__recording_2600021433[in basecamp]
as this one seems to be already in a more sorted form

.Swap
|===
| local_swap_id
| shared_swap_id
| alpha_ledger_protocol (han_bitcoin, han_eth, herc20, halight)
| beta_ledger_protocol (han_bitcoin, han_eth, herc20, halight)
| counter_party : {peer_id, address_hint}
| secret_hash
| role: (alice, bob)
|===

.Han_Bitcoin
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Han_Ethereum
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Herc20
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| token_contract
| network
| expiry
| state: (deployed, funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.HaLight
|===
| redeem_identity
| refund_identity
| amount
| expiry
| cltv_expiry
| chain
| network
| state: (started, opened, accepted, settled, cancelled)
| hash_function
|===

.Swap Communication State
|===
| awaiting announcement
| awaiting announcement failed
| awaiting announcement timeout
| finalized
|===

.Swap State
|===
| in_progress
| not_swapped (error state)
| swapped (success state)
| internal_error
|===


=== Phase 1

Let's review and form 1 NF:
1) each cell to be a single value
2) entries in a column are of the same type
3) rows are uniquely identified - i.e. each row has a unique ID

.Swap
|===
| pk local_swap_id
| shared_swap_id
| counter_party_peer_id
| role: (alice, bob)
|===

1) we removed `alpha/beta_ledger_protocol` because diesel only supports child to parent foreign keys.
2) the problem with `counter_party` is that `address_hint` depends on the role: Bob does not know an `address_hint` from Alice. Hence, we extracted it into an own table

.Address_hint
|===
| pk fk counter_party_peer_id
| address_hint
|===

3) We extracted `secret_hash` into its own table where `local_swap_id` is fk and pk at the same time, because there can only be 1 `secret_hash` per swap.

.Secret_hash
|===
| pk fk local_swap_id
| secret_hash
|===


.Han_Bitcoin
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Han_Ethereum
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Herc20
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| token_contract
| network
| expiry
| state: (deployed, funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.HaLight
|===
| redeem_identity
| refund_identity
| amount
| expiry
| cltv_expiry
| chain
| network
| state: (started, opened, accepted, settled, cancelled)
| hash_function
|===

.Swap Communication State
|===
| awaiting announcement
| awaiting announcement failed
| awaiting announcement timeout
| finalized
|===

.Swap State
|===
| in_progress
| not_swapped (error state)
| swapped (success state)
| internal_error
|===


----
== Open Questions

* Where do we store the swap secret?
