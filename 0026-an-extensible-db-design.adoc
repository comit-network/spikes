= Database design for cnd
Philipp Hoenisch <philipp@coblox.tech>; Daniel Karzel <daniel.karzel@coblox.tech>;
:toc:
:revdate: 2020-04-23

NOTE: Author: {authors} +
Date: {revdate} +
Status: Draft

== Problem

Our current database design is complex and hard to maintain or extend.
The purpose of this spike is to propose a properly normalized relational database model.

=== Scope

The cnd database is used for the (sole) purpose of allowing recovery and efficiently restarting cnd nodes.
We do not follow a model-driven approach where the database dictates e.g. what swap combinations are actually possible.
It is out of scope for this spike to come up with a domain model, the spike should focus only on a model for the relevant data.
This model, however, should adhere to database normalization constraints.

The following protocols are in scope:
* HAN
* HErc20
* HALight

Protocols based on scriptless scripts are not in focus, but known features (e.g. no secret) can be taken into consideration.

=== Database normalization

Database normalization is a process to organize a database into tables and columns.
The main idea with this is that a table should be about a specific topic and only supporting topics included.
If a table is not properly normalized and has data redundancy then it will not only eat up extra memory space but will also make it difficult to handle and update the database, without facing data loss.
Insert, Update and Delete anomalies are very frequent if database is not normalized.
There are three main reasons to normalize a database.

* to minimize duplicate data,
* to minimize or avoid data modification issues,
* to simplify queries.

Most database models are free of anomalies when reaching 3 NF footnote:[https://en.wikipedia.org/wiki/Database_normalization]; note that some models may require BCNF (extension of 3NF).
Normalizing the database model beyond 3 NF is not in scope of this spike but might be considered of deemed necessary.

==== 1 NF:
* each cell to be a single value
* entries in a column are of the same type
* rows are uniquely identified - i.e. each row has a unique ID

==== 2 NF:
* all attributes (non-key columns) depend on the key - if not, then a conjunction table should be created consisting out of 2 keys joining two otherwise not dependent tables (e.g. protocol and swap)

==== 3 NF:
* all fields (all columns) can be determined only by the key in the table and no other column. E.g. if for every Han_BTC swap we have the same expiries, then this should be an own table. --> update anomaly

==== BCNF
* any part of a primary key must not have a functional dependency on another column of the table.

==== 4 NF:
* no multi-valued dependencies. E.g. a customer who bought 2 items should not be in a table twice with the bought item in one column


== Approach

. Data collection: Collect all the data to be stored.
. First model: Create a first model to act upon.
. Iterations: Iterate on the model to improve and normalize it.
. Final proposed model

Constraints we considered besides the normalization constraints:

. FK  relationships should not be defined in a parent table (problem of not being able to create the parent if the child does not exist)
. Certain data of a swap is only known at a later point in time (after creation of the swap). We want to avoid updates.


== Data collection

We identified the following data sources needed:

. Initial data of each swap when being created for a specific role for a specific alpha and beta to protocol where alpha and beta is one of: `HAN`, `HErc20`, `HALight`
. Additional data added to the swap's alpha or beta ledger data.

Probably actually  no in scope but currently in the model ðŸ˜¬:

. Swap State (one per swap, aggregated state - record all states with timestamp)
. Communication State (one per swap - record all states with timestamp)
. Ledger State (two per swap, record all states with timestamp and additional information if applicable, e.g. transaction ID)

Note: It is disputable if we actually have to record all the different swap states for each swap.
It might be sufficient to record the
The same accounts for the communication state.

== First model

Instead of going from what we have right now, we start with a slightly adapted table layout based on the one proposed by @bonomat
https://3.basecamp.com/4403044/buckets/16118249/messages/2583518881#__recording_2600021433[in basecamp]
as this one seems to be already in a more sorted form

.Swap
|===
| local_swap_id
| shared_swap_id
| alpha_ledger_protocol (han_bitcoin, han_eth, herc20, halight)
| beta_ledger_protocol (han_bitcoin, han_eth, herc20, halight)
| counter_party : {peer_id, address_hint}
| secret_hash
| role: (alice, bob)
|===

.Han_Bitcoin
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Han_Ethereum
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Herc20
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| token_contract
| network
| expiry
| state: (deployed, funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.HaLight
|===
| redeem_identity
| refund_identity
| amount
| expiry
| cltv_expiry
| chain
| network
| state: (started, opened, accepted, settled, cancelled)
| hash_function
|===

.Swap Communication State
|===
| awaiting announcement
| awaiting announcement failed
| awaiting announcement timeout
| finalized
|===

.Swap State
|===
| in_progress
| not_swapped (error state)
| swapped (success state)
| internal_error
|===

== Iterations

=== Iteration 1

Let's review and form 1 NF:
1) each cell to be a single value
2) entries in a column are of the same type
3) rows are uniquely identified - i.e. each row has a unique ID

.Swap
|===
| pk local_swap_id
| shared_swap_id
| counter_party_peer_id
| role: (alice, bob)
|===

1) we removed `alpha/beta_ledger_protocol` because diesel only supports child to parent foreign keys. Also, these values are not bound to the table's pk. We will introduce a joint table `swap_ledger_relations` further down below.
2) the problem with `counter_party` is that `address_hint` depends on the role: Bob does not know an `address_hint` from Alice. Hence, we extracted it into an own table

.Address_hint
|===
| pk fk counter_party_peer_id
| address_hint
|===

3) We extracted `secret_hash` into its own table where `local_swap_id` is fk and pk at the same time, because there can only be 1 `secret_hash` per swap.

.Secret_hash
|===
| pk fk local_swap_id
| secret_hash
|===

.Swap_ledger_relations
|===
| pk fk local_swap_id
| fk alpha_swap_details -> e.g. Han_Bitcoin_Swap_Details.id
| fk beta_swap_details -> e.g. Han_Ethereum_Swap_Details.id
|===

.Han_Bitcoin_Swap_Details
|===
| id
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Han_Ethereum_Swap_Details
|===
| id
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

4) We could combine all `Han` tables as they store the same information. We decided against it as the types are different. Nevertheless, the `states` are the same for all `Han` protocols. Hence, we extract the states into a _static_ table `Han_ledger_states`. A simple joint table for all Han-protocols would not work as we need to define a fk from this joint table to the specific  `han_ledger_states_joint_table`.

.Han_ledger_states
|===
| id | state
| 0 | funded
| 1 | redeemed
| 2 | refunded
| 3 | incorrectly_funded
|===

// TODO come up with a better name
.han_bitcoin_ledger_states_joint_table
|===
| pk id
| fk swap_details.id
| fk han_states.id --> han_bitcoin_swap_details
| transaction_id
| at: (timestamp)
|===

// TODO come up with a better name
.han_ethereum_ledger_states_joint_table
|===
| pk id
| fk swap_details.id
| fk han_states.id --> han_ethereum_swap_details
| transaction_id
| at: (timestamp)
|===


5) We repeat the same as above for Herc20 and extract `Herc20_states` including a joint table `herc20_states_joint_table`.

.Herc20_Swap_Details
|===
| id
| swaps_id
| refund_identity
| redeem_identity
| amount
| token_contract
| network
| expiry
| state: (deployed, funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Herc20_states
|===
| id | state
| 0 | deployed
| 1 | funded
| 2 | redeemed
| 3 | refunded
| 4 | incorrectly_funded
|===

// TODO come up with a better name
.herc20_states_joint_table
|===
| pk id
| fk swap_details.id
| fk herc20_states.id
| transaction_id
| at: (timestamp)
|===

.HaLight_Swap_Details
|===
| id
| redeem_identity
| refund_identity
| amount
| expiry
| cltv_expiry
| chain
| network
| state: (started, opened, accepted, settled, cancelled)
| hash_function
|===

6) We repeat the same as above for HaLight and extract `HaLight_states` including a joint table `halight_states_joint_table`.

.Herc20_states
|===
| id | state
| 0 | started
| 1 | opened
| 2 | accepted
| 3 | settled
| 4 | canceled
|===

// TODO come up with a better name
.halight_states_joint_table
|===
| pk id
| fk swap_details (protocol.id)
| fk halight_states.id
| at: (timestamp)
|===

7) We do the same procedure on the swap communication states

.Swap_communication_states
|===
| id | state
| 0 | awaiting announcement
| 1 | awaiting announcement failed
| 2 | awaiting announcement timeout
| 3 | finalized
|===

// TODO come up with a better name
.swap_communication_states_joint_table
|===
| pk id
| fk local_swap_id
| fk Swap_communication_states.id
| at: (timestamp)
|===

8) A swap state can be derived from a combination of `swap_communication_states` and `ledger_states`.
For the sake of efficiency we keep the table `swap_states` though and additionally introduce a joint table `swap_states_joint_table` to record a ledger's state.

.Swap State
|===
| id | state
| 0 | in_progress
| 1 | not_swapped (error state)
| 2 | swapped (success state)
| 3 | internal_error
|===

// TODO come up with a better name
.swap_states_joint_table
|===
| pk id
| fk swap_details (protocol.id)
| fk halight_states.id
| at: (timestamp)
|===

----
== Open Questions

* Where do we store the swap secret?
