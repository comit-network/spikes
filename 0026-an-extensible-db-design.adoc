= Database design for cnd
Philipp Hoenisch <philipp@coblox.tech>
:toc:
:revdate: 2020-04-23

NOTE: Author: {authors} +
Date: {revdate} +
Status: Draft



== Problem

Our current database design is complex and hard to maintain or extend.

The goal of the database is to allow recovery and efficiently restarting cnd nodes.

=== Out of scope:
We won't follow a model-driven approach where the database dictates what swap combinations are actually possible.

=== Database normalization

Database normalization is a process to organize a database into tables and columns.
The main idea with this is that a table should be about a specific topic and only supporting topics included.
If a table is not properly normalized and has data redundancy then it will not only eat up extra memory space but will also make it difficult to handle and update the database, without facing data loss. Insertion, Updation and Deletion Anomalies are very frequent if database is not normalized.
There are three main reasons to normalize a database.

* to minimize duplicate data,
* to minimize or avoid data modification issues,
* to simplify queries.


==== 1 NF:
* each cell to be a single value
* entries in a column are of the same type
* rows are uniquely identified - i.e. each row has a unique ID

==== 2 NF:
* all attributes (non-key columns) depend on the key - if not, then a conjunction table should be created consisting out of 2 keys joining two otherwise not dependent tables (e.g. protocol and swap)

==== 3 NF:
* all fields (all columns) can be determined only by the key in the table and no other column. E.g. if for every Han_BTC swap we have the same expiries, then this should be an own table. --> update anomaly

==== 4 NF:
* no multi-valued dependencies. E.g. a customer who bought 2 items should not be in a table twice with the bought item in one column


== What is the data we need to store

.Swap Swap
|===
|Swap request | Description

| sent
|

| received
|

| accepted (finalized)
|

| deployed
|

| funded
|

| invalid_funded
|

| redeemed
|

| refunded
|

|===


.Swap Swap
|===
|Swap events | Description

| on_chain_events
|

| off_chain_events
|

|===


== Database normalization

=== Phase 0

Instead of going from what we have right now, we start with a slightly adapted table layout based on the one proposed by @bonomat
https://3.basecamp.com/4403044/buckets/16118249/messages/2583518881#__recording_2600021433[in basecamp]
as this one seems to be already in a more sorted form

.Swap
|===
| local_swap_id
| shared_swap_id
| alpha_ledger_protocol (han_bitcoin, han_eth, herc20, halight)
| beta_ledger_protocol (han_bitcoin, han_eth, herc20, halight)
| counter_party : {peer_id, address_hint}
| secret_hash
| role: (alice, bob)
|===

.Han_Bitcoin
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Han_Ethereum
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Herc20
|===
| swaps_id
| refund_identity
| redeem_identity
| amount
| token_contract
| network
| expiry
| state: (deployed, funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.HaLight
|===
| redeem_identity
| refund_identity
| amount
| expiry
| cltv_expiry
| chain
| network
| state: (started, opened, accepted, settled, cancelled)
| hash_function
|===

.Swap Communication State
|===
| awaiting announcement
| awaiting announcement failed
| awaiting announcement timeout
| finalized
|===

.Swap State
|===
| in_progress
| not_swapped (error state)
| swapped (success state)
| internal_error
|===


=== Phase 1

Let's review and form 1 NF:
1) each cell to be a single value
2) entries in a column are of the same type
3) rows are uniquely identified - i.e. each row has a unique ID

.Swap
|===
| pk local_swap_id
| shared_swap_id
| counter_party_peer_id
| role: (alice, bob)
|===

1) we removed `alpha/beta_ledger_protocol` because diesel only supports child to parent foreign keys. Also, these values are not bound to the table's pk. We will introduce a joint table `swap_ledger_relations` further down below.
2) the problem with `counter_party` is that `address_hint` depends on the role: Bob does not know an `address_hint` from Alice. Hence, we extracted it into an own table

.Address_hint
|===
| pk fk counter_party_peer_id
| address_hint
|===

3) We extracted `secret_hash` into its own table where `local_swap_id` is fk and pk at the same time, because there can only be 1 `secret_hash` per swap.

.Secret_hash
|===
| pk fk local_swap_id
| secret_hash
|===

.Swap_ledger_relations
|===
| pk fk local_swap_id
| fk alpha_swap_details -> e.g. Han_Bitcoin_Swap_Details.id
| fk beta_swap_details -> e.g. Han_Ethereum_Swap_Details.id
|===

.Han_Bitcoin_Swap_Details
|===
| id
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Han_Ethereum_Swap_Details
|===
| id
| swaps_id
| refund_identity
| redeem_identity
| amount
| network
| expiry
| state: (funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

4) We could combine all `Han` tables as they store the same information. We decided against it as the types are different. Nevertheless, the `states` are the same for all `Han` protocols. Hence, we extract the states into a _static_ table `Han_ledger_states`. A simple joint table for all Han-protocols would not work as we need to define a fk from this joint table to the specific  `han_ledger_states_joint_table`.

.Han_ledger_states
|===
| id | state
| 0 | funded
| 1 | redeemed
| 2 | refunded
| 3 | incorrectly_funded
|===

// TODO come up with a better name
.han_bitcoin_ledger_states_joint_table
|===
| pk id
| fk swap_details.id
| fk han_states.id --> han_bitcoin_swap_details
| transaction_id
| at: (timestamp)
|===

// TODO come up with a better name
.han_ethereum_ledger_states_joint_table
|===
| pk id
| fk swap_details.id
| fk han_states.id --> han_ethereum_swap_details
| transaction_id
| at: (timestamp)
|===


5) We repeat the same as above for Herc20 and extract `Herc20_states` including a joint table `herc20_states_joint_table`.

.Herc20_Swap_Details
|===
| id
| swaps_id
| refund_identity
| redeem_identity
| amount
| token_contract
| network
| expiry
| state: (deployed, funded, redeemed, refunded, incorrectly_funded)
| hash_function
|===

.Herc20_states
|===
| id | state
| 0 | deployed
| 1 | funded
| 2 | redeemed
| 3 | refunded
| 4 | incorrectly_funded
|===

// TODO come up with a better name
.herc20_states_joint_table
|===
| pk id
| fk swap_details.id
| fk herc20_states.id
| transaction_id
| at: (timestamp)
|===

.HaLight_Swap_Details
|===
| id
| redeem_identity
| refund_identity
| amount
| expiry
| cltv_expiry
| chain
| network
| state: (started, opened, accepted, settled, cancelled)
| hash_function
|===

6) We repeat the same as above for HaLight and extract `HaLight_states` including a joint table `halight_states_joint_table`.

.Herc20_states
|===
| id | state
| 0 | started
| 1 | opened
| 2 | accepted
| 3 | settled
| 4 | canceled
|===

// TODO come up with a better name
.halight_states_joint_table
|===
| pk id
| fk swap_details (protocol.id)
| fk halight_states.id
| at: (timestamp)
|===

7) We do the same procedure on the swap communication states

.Swap_communication_states
|===
| id | state
| 0 | awaiting announcement
| 1 | awaiting announcement failed
| 2 | awaiting announcement timeout
| 3 | finalized
|===

// TODO come up with a better name
.swap_communication_states_joint_table
|===
| pk id
| fk local_swap_id
| fk Swap_communication_states.id
| at: (timestamp)
|===

8) A swap state can be derived from a combination of `swap_communication_states` and `ledger_states`.
For the sake of efficiency we keep the table `swap_states` though and additionally introduce a joint table `swap_states_joint_table` to record a ledger's state.

.Swap State
|===
| id | state
| 0 | in_progress
| 1 | not_swapped (error state)
| 2 | swapped (success state)
| 3 | internal_error
|===

// TODO come up with a better name
.swap_states_joint_table
|===
| pk id
| fk swap_details (protocol.id)
| fk halight_states.id
| at: (timestamp)
|===

----
== Open Questions

* Where do we store the swap secret?
